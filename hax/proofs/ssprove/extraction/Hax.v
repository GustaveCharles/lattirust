(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Sum.
Export Sum.

Require Import Std_Ops.
Export Std_Ops.

Require Import Add.
Export Add.

Require Import Mul.
Export Mul.

Require Import Num_traits.
Export Num_traits.

Require Import One.
Export One.

Require Import Pow.
Export Pow.

Require Import Zero.
Export Zero.

Require Import Rayon_Prelude.
Export Rayon_Prelude.

Require Import RoundedDiv.
Export RoundedDiv.

(*Not implemented yet? todo(item)*)

Equations recompose {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {v_A : _} {v_B : _} `{ t_Sized v_A} `{ t_Sized v_B} `{ t_Mul v_A v_B} `{ t_Copy v_A} `{ t_Sum v_A v_A} `{ t_Send v_A} `{ t_Sync v_A} `{ t_Clone v_B} `{ t_Mul v_B v_B} `{ t_Add v_B v_B} `{ t_Pow v_B (nseq int64 1)} `{ t_Send v_B} `{ t_Sync v_B} (v : both L1 I1 (t_Vec v_A t_Global)) (b : both L2 I2 v_B) : both (L1 :|: L2) (I1 :|: I2) v_A :=
  recompose v b  :=
    solve_lift (f_sum (f_map (f_enumerate (f_par_iter v)) (fun '(i,vv_i) =>
      vv_i .* (f_pow (f_clone b) (array_from_list [cast_int (WS2 := _) i]))))) : both (L1 :|: L2) (I1 :|: I2) v_A.
Fail Next Obligation.

Definition floor_log_loc : Location :=
  (int128;0%nat).
Equations floor_log {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (x : both L1 I1 int128) (base : both L2 I2 int128) : both (L1 :|: L2 :|: fset [floor_log_loc]) (I1 :|: I2) int128 :=
  floor_log x base  :=
    letb _ := ifb not (base >.? (ret_both (1 : int128)))
    then never_to_any (panic (ret_both (assertion failed: base > 1 : chString)))
    else () in
    letb _ := ifb not (x >=.? (ret_both (1 : int128)))
    then never_to_any (panic (ret_both (assertion failed: x >= 1 : chString)))
    else () in
    letb floor_log loc(floor_log_loc) := ret_both (0 : int128) in
    letb _ := foldi_both_list (f_into_iter (Build_t_RangeFrom (f_start := ret_both (0 : int32)))) (fun _ =>
      ssp (fun _ =>
        solve_lift (ifb x >=.? base
        then letb _ := assign todo(term) in
        letb _ := assign todo(term) in
        ret_both (tt : 'unit)
        else ret_both (tt : 'unit)) : (both (*1*)(L1:|:L2:|:fset [floor_log_loc]) (I1:|:I2) 'unit))) (ret_both (tt : 'unit)) in
    solve_lift floor_log : both (L1 :|: L2 :|: fset [floor_log_loc]) (I1 :|: I2) int128.
Fail Next Obligation.

Equations balanced_decomposition_max_length {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (b : both L1 I1 int128) (max : both L2 I2 int128) : both (L1 :|: L2 :|: fset [floor_log_loc]) (I1 :|: I2) uint_size :=
  balanced_decomposition_max_length b max  :=
    solve_lift (ifb max =.? (ret_both (0 : int128))
    then ret_both (0 : uint_size)
    else ((cast_int (WS2 := _) (floor_log max b)) .+ (ret_both (1 : uint_size))) .+ (ret_both (1 : uint_size))) : both (L1 :|: L2 :|: fset [floor_log_loc]) (I1 :|: I2) uint_size.
Fail Next Obligation.

Definition curr_loc : Location :=
  (int128;1%nat).
Definition decomp_bal_signed_loc : Location :=
  (t_Vec int128 t_Global;2%nat).
Equations decompose_balanced {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} (v : both L1 I1 int128) (b : both L2 I2 int128) (padding_size : both L3 I3 (t_Option uint_size)) (length : both L4 I4 uint_size) : both (L1 :|: L2 :|: L3 :|: L4 :|: fset [curr_loc;decomp_bal_signed_loc]) (I1 :|: I2 :|: I3 :|: I4) (t_Vec int128 t_Global) :=
  decompose_balanced v b padding_size length  :=
    letb _ := ifb not (andb (not (f_is_zero b)) (not (f_is_one b)))
    then never_to_any (panic_fmt (impl_2__new_const (unsize (array_from_list [ret_both (cannot decompose in basis 0 or 1 : chString)]))))
    else () in
    letb _ := matchb prod_b (b .% (ret_both (2 : int128)),ret_both (0 : int128)) with
    | '(left_val,right_val) =>
      solve_lift (ifb not (left_val =.? right_val)
      then letb kind := AssertKind_Eq in
      never_to_any (assert_failed kind left_val right_val (Option_Some (impl_2__new_const (unsize (array_from_list [ret_both (decomposition basis must be even : chString)])))))
      else ())
    end in
    letb b_half_floor := impl__u128__div_euclid b (ret_both (2 : int128)) in
    letb b := cast_int (WS2 := _) b in
    letb decomp_bal_signed loc(decomp_bal_signed_loc) := impl__new (ret_both (tt : 'unit)) in
    letb curr loc(curr_loc) := v in
    letb _ := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := length))) (fun _ =>
      ssp (fun _ =>
        letb rem := curr .% b in
        solve_lift (ifb (cast_int (WS2 := _) (impl__i128__abs rem)) <=.? b_half_floor
        then letb _ := assign todo(term) in
        letb _ := assign todo(term) in
        ret_both (tt : 'unit)
        else letb _ := ifb rem <.? (ret_both (0 : int128))
        then letb _ := assign todo(term) in
        ret_both (tt : 'unit)
        else letb _ := assign todo(term) in
        ret_both (tt : 'unit) in
        letb carry := f_rounded_div rem b in
        letb _ := assign todo(term) in
        ret_both (tt : 'unit)) : (both (*2*)(L1:|:L2:|:L4:|:fset [curr_loc;decomp_bal_signed_loc]) (I1:|:I2:|:I4) 'unit))) (ret_both (tt : 'unit)) in
    letb _ := matchb padding_size with
    | Option_Some_case padding_size =>
      letb padding_size := ret_both ((padding_size) : (uint_size)) in
      letb _ := ifb not ((impl_1__len decomp_bal_signed) <=.? padding_size)
      then never_to_any (panic_fmt (impl_2__new_v1 (unsize (array_from_list [ret_both (padding_size =  : chString);
        ret_both ( must be at least decomp_bal.len() =  : chString)])) (unsize (array_from_list [impl_1__new_display padding_size;
        impl_1__new_display (impl_1__len decomp_bal_signed)]))))
      else () in
      letb _ := assign todo(term) in
      solve_lift (ret_both (tt : 'unit))
    | _ =>
      solve_lift (ret_both (tt : 'unit))
    end in
    solve_lift decomp_bal_signed : both (L1 :|: L2 :|: L3 :|: L4 :|: fset [curr_loc;decomp_bal_signed_loc]) (I1 :|: I2 :|: I3 :|: I4) (t_Vec int128 t_Global).
Fail Next Obligation.
